# R√®gles Cursor - Trakto - Clean Code

## üéØ Principes fondamentaux
- Toujours v√©rifier si un composant existant peut √™tre r√©utilis√© avant d'en cr√©er un nouveau
- Privil√©gier la r√©utilisabilit√© et l'abstraction intelligente
- Code DRY (Don't Repeat Yourself) - √©viter la duplication
- Code succinct et expressif - chaque ligne doit avoir un but
- Segmentation claire pour maintenir la lisibilit√©

## üì¶ TypeScript - Typage strict

### R√®gles de typage
- JAMAIS utiliser le type `any` - toujours d√©finir des types explicites
- Utiliser `unknown` plut√¥t que `any` si un type est vraiment inconnu
- Pr√©f√©rer `interface` √† `type` pour les objets et props de composants
- Toujours typer explicitement les props de composants avec une interface s√©par√©e
- Utiliser `Readonly<T>` pour les props de composants React
- Pr√©f√©rer les types union (`'a' | 'b'`) aux enums quand possible
- Typer explicitement les fonctions, notamment les callbacks

### Nommage des types
- Interfaces de props : `ComponentNameProps` (ex: `ButtonProps`, `UserCardProps`)
- Types utilitaires : PascalCase avec un nom descriptif
- Types union : pr√©f√©rer les literal types plut√¥t que les enums

## ‚öõÔ∏è React/Next.js - Bonnes pratiques

### Structure des composants
- Un composant par fichier
- Nom du fichier en PascalCase correspondant au nom du composant (ex: `UserProfile.tsx` pour `UserProfile`)
- Toujours typer les props avec une interface s√©par√©e export√©e si r√©utilisable
- Pr√©f√©rer les composants serveur (par d√©faut dans Next.js 16)
- Utiliser `const ComponentName` plut√¥t que `function ComponentName`
- Composants fonctionnels uniquement

### Exports
- `export default` uniquement pour les composants de page (`app/**/page.tsx`) et layout (`app/**/layout.tsx`)
- Composants r√©utilisables : `export` nomm√©s uniquement
- Exporter les types/interfaces depuis le m√™me fichier ou un fichier d√©di√© `types/`

### Hooks React
- Toujours fournir toutes les d√©pendances dans les arrays de d√©pendances
- Pr√©f√©rer `useState<T>` avec type explicite
- Utiliser `useCallback`/`useMemo` uniquement si n√©cessaire (optimisation mesur√©e)
- √âviter les hooks personnalis√©s inutiles - privil√©gier la simplicit√©

## üóÇÔ∏è Organisation du code

### Structure de dossiers
```
app/              # Pages et layouts Next.js
components/       # Composants r√©utilisables (PascalCase)
  ui/            # Composants UI de base (Button, Input, etc.)
lib/             # Utilitaires et helpers
types/           # Types TypeScript partag√©s
utils/           # Fonctions utilitaires
```

### R√®gles d'organisation
- Un composant = un fichier
- Composants r√©utilisables dans `components/`
- Types partag√©s dans `types/` ou colocalis√©s avec le composant si sp√©cifique
- Utilitaires dans `lib/` ou `utils/`
- Segmentation : diviser les gros fichiers en modules logiques

### Imports
- Ordre des imports : React/Next ‚Üí biblioth√®ques externes ‚Üí internes ‚Üí types ‚Üí styles
- Toujours utiliser les imports absolus avec `@/` plut√¥t que relatifs `../../`
- Grouper les imports par cat√©gorie avec une ligne vide entre chaque groupe

## üè∑Ô∏è Nommage

### Composants et fichiers
- Composants : PascalCase (`UserProfile`, `NavigationBar`)
- Fichiers de composants : PascalCase correspondant au nom (`UserProfile.tsx`)

### Code JavaScript/TypeScript
- Variables et fonctions : camelCase (`getUserData`, `handleSubmit`)
- Constantes : UPPER_SNAKE_CASE (`API_BASE_URL`, `MAX_RETRY_COUNT`)
- Types/Interfaces : PascalCase (`User`, `ApiResponse`, `ButtonProps`)

## ‚úçÔ∏è Formatage et style

### Style de code
- Guillemets doubles pour les strings
- Point-virgule obligatoire
- Indentation : 2 espaces
- Longueur de ligne max : 100 caract√®res (pr√©f√©rer le retour √† la ligne)
- Pas d'espaces en fin de ligne
- Ligne vide √† la fin des fichiers
- Utiliser des trailing commas dans les objets/arrays multilignes

### JSX/TSX
- Props sur plusieurs lignes si plus de 2 props
- Pr√©f√©rer les props auto-fermantes pour les composants sans enfants
- Utiliser des fragments (`<>...</>`) plut√¥t que des divs wrapper inutiles

## üîß Fonctions et logique

### R√®gles de fonction
- Code DRY : extraire la logique r√©p√©t√©e en fonctions utilitaires
- Une fonction = une responsabilit√© claire
- Maximum 3-4 param√®tres (sinon utiliser un objet de param√®tres)
- Noms de fonctions verbeux et explicites (`handleFormSubmit` plut√¥t que `onClick`)
- Early returns pour r√©duire la complexit√© et am√©liorer la lisibilit√©
- Fonctions courtes (id√©alement < 30 lignes, max 50)
- Code succinct : √©viter le code verbeux inutile

### Exemples √† √©viter
```typescript
// ‚ùå √âviter
const data = items.map((item) => {
  return item.name;
});

// ‚úÖ Pr√©f√©rer
const data = items.map(item => item.name);
```

## üö® Gestion des erreurs

- Toujours g√©rer les erreurs (try/catch, .catch() pour les promesses)
- Messages d'erreur explicites et utiles
- Loguer les erreurs en d√©veloppement pour le debugging
- √âviter les try/catch silencieux sans traitement

## ‚ö° Performance Next.js

- Toujours utiliser `next/image` plut√¥t que `<img>` natif
- Utiliser `next/font` pour les polices (d√©j√† en place)
- Lazy loading des composants lourds avec `dynamic()` de Next.js
- √âviter les inline functions dans JSX si elles causent des re-renders
- Optimiser les imports (√©viter les imports wildcard `*`)

## ‚ôø Accessibilit√©

- Toujours inclure `alt` descriptif sur les images
- Utiliser des √©l√©ments HTML s√©mantiques appropri√©s
- G√©rer le focus clavier pour les interactions
- ARIA labels quand le HTML s√©mantique ne suffit pas
- Contraste de couleurs suffisant (suivi par Tailwind)

## üé® CSS/Tailwind

### R√®gles Tailwind
- Pr√©f√©rer les classes Tailwind aux styles inline
- Extraire les classes r√©p√©titives en composants r√©utilisables plut√¥t qu'en variables CSS
- Utiliser les variants Tailwind (`hover:`, `dark:`, etc.) plut√¥t que les conditions JS
- √âviter `!important` sauf cas sp√©cifiques document√©s
- Organiser les classes : layout ‚Üí spacing ‚Üí typography ‚Üí colors ‚Üí effects

### Exemple
```tsx
// ‚ùå √âviter la duplication
<div className="px-4 py-2 bg-blue-500 text-white rounded">Button</div>
<div className="px-4 py-2 bg-blue-500 text-white rounded">Button 2</div>

// ‚úÖ Extraire en composant r√©utilisable
<Button>Button</Button>
<Button>Button 2</Button>
```

## üîí S√©curit√©

- Sanitizer tous les inputs utilisateur
- Valider les donn√©es c√¥t√© serveur (Next.js API routes)
- Toujours utiliser `rel="noopener noreferrer"` sur les liens externes (`target="_blank"`)
- Ne jamais exposer de secrets, tokens ou cl√©s API dans le code client

## üìù Commentaires et documentation

### R√®gles de documentation
- Code auto-document√© : noms de variables/fonctions clairs et explicites
- Commentaires uniquement pour expliquer le "pourquoi", pas le "quoi"
- JSDoc uniquement pour les fonctions publiques/complexes n√©cessitant une documentation
- **Pas de fichiers Markdown (README, CHANGELOG, etc.) sauf absolument n√©cessaire**

### Exemples
```typescript
// ‚ùå Commentaire inutile
// Incr√©mente le compteur
counter++;

// ‚úÖ Code auto-document√©
incrementCounter();

// ‚úÖ Commentaire utile (explique le pourquoi)
// Utiliser requestIdleCallback pour √©viter de bloquer le thread principal
requestIdleCallback(() => {
  processLargeDataset();
});
```

## üîÑ R√©utilisabilit√© des composants

### Processus de cr√©ation
1. **Toujours rechercher** d'abord dans `components/` si un composant similaire existe
2. Si un composant existe mais n'est pas parfait : l'√©tendre avec des props plut√¥t que cr√©er un nouveau
3. Si aucun composant appropri√© : cr√©er un composant r√©utilisable dans `components/`
4. √âviter les composants trop sp√©cifiques qui ne seront utilis√©s qu'une fois

### Abstractions
- Cr√©er des composants de base r√©utilisables dans `components/ui/`
- Utiliser la composition plut√¥t que la duplication
- Props g√©n√©riques avec TypeScript pour la flexibilit√©

## üéØ Segmentation du code

### Principes
- Diviser les gros composants (> 150 lignes) en sous-composants
- Extraire la logique m√©tier des composants dans des fonctions utilitaires
- S√©parer les types, constantes et utilitaires dans des fichiers d√©di√©s si r√©utilisables
- Maintenir chaque fichier focalis√© sur une seule responsabilit√©

### Exemple de segmentation
```typescript
// ‚ùå Composant monolithique
export function UserProfile() {
  // 200 lignes de logique et JSX m√©lang√©s
}

// ‚úÖ Composant segment√©
// UserProfile.tsx
import { UserHeader } from './UserHeader';
import { UserStats } from './UserStats';
import { useUserData } from '@/lib/hooks/useUserData';

export function UserProfile({ userId }: UserProfileProps) {
  const user = useUserData(userId);
  return (
    <div>
      <UserHeader user={user} />
      <UserStats user={user} />
    </div>
  );
}
```

## üö´ √Ä √©viter absolument

- ‚ùå Type `any`
- ‚ùå Duplication de code (DRY)
- ‚ùå Composants trop sp√©cifiques non r√©utilisables
- ‚ùå Fichiers trop longs (> 300 lignes)
- ‚ùå Tests unitaires (pas demand√©s par le projet)
- ‚ùå Documentation Markdown inutile
- ‚ùå Code verbeux et r√©p√©titif
- ‚ùå Imports relatifs `../../` au lieu de `@/`